# 一、pom文件解析
1. spring-boot-starter-parent：继承spring-boot-starter-parent包来获得一些合理的默认配置

2. spring-boot-starter：Spring Boot的核心启动器，包含了自动配置、日志和YAML

3. spring-boot-starter-web：将项目变成web项目，包含RESTful风格框架SpringMVC和默认的嵌入式容器Tomcat，本身也依赖spring-boot-starter

4. mybatis-spring-boot-starter：spring boot和mybatis的整合包

# 二、@SpringBootApplication
1. 启动springboot项目的注解，替代了@@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan这三个注解的功能

2. @SpringBootConfiguration，继承自@Configuration，一般与@Bean配合使用，使用这两个注解就可以创建一个简单的spring配置类，可以用来**替代相应的xml配置文件**

3. @EnableAutoConfiguration，可以根据你添加的jar包来配置你项目的默认配置，比如当你添加了mvc的jar包，它就会自动配置web项目所需的配置

4. @ComponentScan：扫描组件，只要组件上有@component及其子注解@Service、@Repository、@Controller等，springboot会自动扫描到并纳入Spring 容器进行管理，有点类似xml文件中的<context:component-scan>，该注解不填属性的话就是默认扫描启动类所在的包，或者启动类所在包的下一级，所以**启动类要放在最外层**

# 三、通过配置类和注解代替配置文件
1. springboot可以把以前写的配置文件的内容都写进Config配置类里面，并且在配置类打上Configuration注解，告诉spring这是个配置类，扫描这个类里的配置信息

   1. 在类里面的配置属性上面加@Value注解引入properties文件的值
      ```
             @Value("${spring.datasource.url}")
             private String url;
      ```
   
   2. 在类里面用@Bean注解定义一个方法返回一个类被spring管理
      1. 类的属性可以在方法里面定义
         ```
            @Bean("productConfig")
            public ProductConfig productConfig(){
                ProductConfig pc = new ProductConfig();
                pc.age = 11;
                pc.name = "gunners";
                return pc;
            }
         ```
      
      2. 也可以用@ConfigurationProperties注解引入properties文件的值，但是要是yml文件的格式
         ```
            @Bean
            @ConfigurationProperties(prefix = "spring.datasource") //这里要引用yml文件的数据
            public DataSource dataSource(){
                return new DruidDataSource();
            }
         ```

3. 如果实体类在属性上面加@Value注解引入properties文件的值的同时别的类中也用@Bean注解定义了该实体类并给属性赋值（就是上面1,2种情况），那么实体类自动注入后属性的默认值还是@Value注解引入的properties定义的值

# 四、 springboot整合Mybatis
1. 单数据源
   1. 配置properties文件
      ```
         spring.datasource.url=jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf8
         spring.datasource.username=root
         spring.datasource.password=123456
         spring.datasource.driver-class-name=com.mysql.jdbc.Driver
         mybatis.mapper-locations=classpath:mapper/*.xml
      ```
   
   2. 定义dao层，写mapper接口
   
   3. 配置mapper.xml文件，在resources文件夹下建一个mapper文件夹放进去，并且指定namespace为dao层的包路径
   
   4. 在mybatis的config类里面（如果有的话）和Application启动类打上@MapperScan注解扫描dao层的包路径
   
   5. 如果使用springboot默认的数据源，则只需在application.properties文件中写配置信息，不用另外写Config类，因为它会自动配置数据源和mybatis相关配置，可以查看MybatisAutoConfiguration类源码，所以使用默认数据源时Config类不是必须的
   
2. 多数据源  
   1. 数据源的定义：数据源表示一个与数据库的连接（传统）或者表示很多与数据库的连接（使用数据库连接池）
   
   2. 步骤
      1. 配置yml文件
         ```
            spring:
                 datasource:
                    #主数据库
                    master:
                        driver-class-name: com.mysql.jdbc.Driver
                        jdbc-url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf-8
                        username: root
                        password: 123456
                    #从数据库
                    cluster:
                        driver-class-name: com.mysql.jdbc.Driver
                        jdbc-url: jdbc:mysql://localhost:3306/test2?useUnicode=true&characterEncoding=utf-8
                        username: root
                        password: 123456
         ```
      
      2. 写Config类
         1. 主库配置类（主库要在配置类方法上面加@Primary注解，从库不用）
            ```
               @Configuration
               @MapperScan(basePackages = "com.example.project.dao.master",sqlSessionTemplateRef = "masterSqlSessionTemplate")
               public class MasterDataSourceConfig {

               //    创建DataSource
                   @Bean(name = "masterDataSource")
                   @ConfigurationProperties(prefix = "spring.datasource.master")
                   @Primary
                   public DataSource masterDataSource(){
                       return DataSourceBuilder.create().build();
                   }

               //    创建工厂
                   @Bean(name = "masterSqlSessionFactory")
                   @Primary
                   public SqlSessionFactory masterSqlSessionFactory(@Qualifier("masterDataSource")DataSource dataSource) throws Exception{
                       SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
                       bean.setDataSource(dataSource);
                       bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(
                               "classpath:mapper/master/*.xml"));
                       return bean.getObject();
                   }

               //    创建事务
                   @Bean(name = "masterTransactionManager")
                   @Primary
                   public DataSourceTransactionManager masterTransactionManager(@Qualifier("masterDataSource")
                                                                                            DataSource dataSource){
                       return new DataSourceTransactionManager(dataSource);
                   }

               //    创建模板
                   @Bean(name = "masterSqlSessionTemplate")
                   @Primary
                   public SqlSessionTemplate masterSqlSessionTemplate(@Qualifier("masterSqlSessionFactory")
                                                                      SqlSessionFactory sqlSessionFactory){
                       return new SqlSessionTemplate(sqlSessionFactory);
                   }
               }
            ```
            
         2. 从库配置类
            ```
               @Configuration
               @MapperScan(basePackages = "com.example.project.dao.cluster",sqlSessionTemplateRef = "clusterSqlSessionTemplate")
               public class ClusterDataSourceConfig {
                   //    创建DataSource
                   @Bean(name = "clusterDataSource")
                   @ConfigurationProperties(prefix = "spring.datasource.cluster")
                   public DataSource masterDataSource(){
                       return DataSourceBuilder.create().build();
                   }

                   //    创建工厂
                   @Bean(name = "clusterSqlSessionFactory")
                   public SqlSessionFactory masterSqlSessionFactory(@Qualifier("clusterDataSource")DataSource dataSource) throws Exception{
                       SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
                       bean.setDataSource(dataSource);
                       bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(
                               "classpath:mapper/cluster/*.xml"));
                       return bean.getObject();
                   }

                   //    创建事务
                   @Bean(name = "clusterTransactionManager")
                   @Primary
                   public DataSourceTransactionManager masterTransactionManager(@Qualifier("clusterDataSource")
                                                                                        DataSource dataSource){
                       return new DataSourceTransactionManager(dataSource);
                   }

                   //    创建模板
                   @Bean(name = "clusterSqlSessionTemplate")
                   public SqlSessionTemplate masterSqlSessionTemplate(@Qualifier("clusterSqlSessionFactory")
                                                                              SqlSessionFactory sqlSessionFactory){
                       return new SqlSessionTemplate(sqlSessionFactory);
                   }
               }
            ```
         
         3. 上面是针对使用默认数据源的配置，如果使用其他数据源，例如阿里的driud，只需做如下修改：
            
            1. 将配置类中创建DataSource的方法中的DataSourceBuilder改为DuridDataSourceBuilder
            
      3. 在resources文件夹下新建mapper文件夹，写mapper.xml文件            
   
# 五、 springboot整合Redis
1. springboot序列化对象
   1. RedisTemplate可以存储对象，但要实现Serializable接口，以二进制数组方式存储，内容没有可读性
   
   2. 下列方法可以序列化对象，同时可读性又强
      1. GenericToStringSerializer: 可以将任何对象泛化为字符串并序列化

      2. Jackson2JsonRedisSerializer: 跟JacksonJsonRedisSerializer实际上是一样的
      
      3. JacksonJsonRedisSerializer: 序列化object对象为json字符串

      4. JdkSerializationRedisSerializer: 序列化java对象

      5. StringRedisSerializer: 简单的字符串序列化






