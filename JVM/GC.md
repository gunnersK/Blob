* 程序计数器、虚拟机栈、本地方法栈这三个区域随线程而生、灭，所以他们的内存分配和回收都具备确定性，方法或线程结束时，内存自然也跟着回收了但是java堆只有在程序运行期间才知道创建哪些对象，内存分配和回收都是动态的，GC关注的就是这部分内存

# 一、对象存活判断
   1. 引用计数算法
      1. 当有一个地方引用这个对象，计数器就加1，引用失效就减1，当计数器为0，这个对象就不可能再被使用
      2. 但是java不用计数算法，因为不能解决对象之间相互循环引用的问题
   2. 根搜索算法
      1. 通过一系列的GC Roots对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的，会被判定是可回收对象。例如对象循环引用，但是他们到GC Roots不可达，所以可回收
      2. 可以做GC Roots的对象包括：
         1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
         2. 方法区中的类静态属性引用的对象
         3. 方法区中的常量引用的对象
         4. 本地方法栈中（Native方法）引用的对象
   3. 引用类型
      1. 强引用(Strong)--只要强引用还存在，GC永远不会回收掉这个对象。类似 Object obj = new Object() 
      2. 软引用(Soft)
      3. 弱引用(Weak)
      4. 虚引用(Phantom)
   4. 对象自救      
      1. finalize()方法
         1. GC在准备释放对象占用的存储空间时，首先调用finalize()方法
         2. 只是调用一下这个方法而已，回收对象的这个动作不在这个方法里，调不调用和回收对象没什么关系，就算不调用finalize()方法也可以回收对象
         3. 而且对象还可以通过这个方法自救
         4. 任何对象的finalize()方法只会被JVM调用一次
      2. 对象通过finalize()方法自救：
         重写finalize()方法，重新把自己(this)与引用链上的任何一个对象建立关联，比如把this赋值给某个类变量或对象的成员变量，这样被GC执行完finalize()方法之后，就不会被回收，还可以存活下来
      3. 如果对象进行根搜索后发现没有与GC Roots相连的引用链，那他会被第一次标记，并筛选判断是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()已经被JVM调用过，都被视为没必要执行
         1. 有必要执行（重写了finalize()方法或者没被JVM调用过）：对象会被放置在一个F-Queue队列中，稍后由一条低优先级的的Finalizer线程去执行，这时对象可以在finalize()方法里面通过重新赋值引用对象存活下来，联系第2点，那在第二次标记时它将被移出“即将回收”的集合
         2. 没必要执行：没有覆盖finalize()方法，或者finalize()已经被JVM调用过就不会被执行，直接回收了
      4. 如果一个对象通过finalize()自救成功，那么下次回收对象，他的finalize()方法不会被再次执行，他就会被回收了         
